#!/bin/bash
#
# Pre-commit hook for secret detection
#
# This hook prevents commits containing potential secrets, API keys, or credentials
# from entering the repository. It's the only pre-commit validation we use to 
# maintain developer workflow while preventing credential leaks.

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

echo -e "${GREEN}ðŸ” Scanning for secrets and credentials...${NC}"

# Get list of files being committed
FILES=$(git diff --cached --name-only --diff-filter=ACM)

# Exit early if no files to check
if [ -z "$FILES" ]; then
    echo -e "${GREEN}âœ… No files to scan${NC}"
    exit 0
fi

# Secret patterns to detect
SECRETS_FOUND=false
BLOCKED_FILES=()

# Function to check for secrets in a file
check_secrets() {
    local file="$1"
    local violations=()
    
    # Skip binary files
    if ! git show ":$file" | file - | grep -q text; then
        return 0
    fi
    
    # Get file content being committed
    CONTENT=$(git show ":$file")
    
    # API Key patterns
    if echo "$CONTENT" | grep -iE "(api[_-]?key|apikey)[\"']?\s*[:=]\s*[\"'][a-zA-Z0-9_-]{20,}[\"']" >/dev/null; then
        violations+=("API key pattern")
    fi
    
    # AWS credentials
    if echo "$CONTENT" | grep -E "AKIA[0-9A-Z]{16}" >/dev/null; then
        violations+=("AWS Access Key")
    fi
    
    if echo "$CONTENT" | grep -E "aws_secret_access_key.*[A-Za-z0-9/+=]{40}" >/dev/null; then
        violations+=("AWS Secret Key")
    fi
    
    # Generic secret patterns
    if echo "$CONTENT" | grep -iE "(secret|password|passwd|pwd)[\"']?\s*[:=]\s*[\"'][^\"']{8,}[\"']" >/dev/null; then
        violations+=("Password/Secret pattern")
    fi
    
    # Database connection strings
    if echo "$CONTENT" | grep -iE "(mysql://|postgresql://|mongodb://)[^\"'\s]*:[^\"'\s]*@" >/dev/null; then
        violations+=("Database connection string with credentials")
    fi
    
    # Private keys
    if echo "$CONTENT" | grep -E "\-\-\-\-\-BEGIN[A-Z ]*PRIVATE KEY\-\-\-\-\-" >/dev/null; then
        violations+=("Private key")
    fi
    
    # JWT tokens (basic detection)
    if echo "$CONTENT" | grep -E "ey[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*" >/dev/null; then
        violations+=("Potential JWT token")
    fi
    
    # Slack tokens
    if echo "$CONTENT" | grep -E "xox[baprs]-[0-9]{12}-[0-9]{12}-[a-zA-Z0-9]{24}" >/dev/null; then
        violations+=("Slack token")
    fi
    
    # GitHub tokens
    if echo "$CONTENT" | grep -E "gh[pousr]_[A-Za-z0-9_]{36}" >/dev/null; then
        violations+=("GitHub token")
    fi
    
    # If violations found, report them
    if [ ${#violations[@]} -gt 0 ]; then
        echo -e "${RED}âŒ SECRETS DETECTED in $file:${NC}"
        for violation in "${violations[@]}"; do
            echo -e "${RED}   - $violation${NC}"
        done
        BLOCKED_FILES+=("$file")
        SECRETS_FOUND=true
        return 1
    fi
    
    return 0
}

# Check each file being committed
for file in $FILES; do
    # Skip deleted files
    if [ ! -f "$file" ]; then
        continue
    fi
    
    check_secrets "$file"
done

# Final result
if [ "$SECRETS_FOUND" = true ]; then
    echo ""
    echo -e "${RED}ðŸš¨ COMMIT BLOCKED: Potential secrets detected!${NC}"
    echo ""
    echo -e "${YELLOW}Files with potential secrets:${NC}"
    for blocked_file in "${BLOCKED_FILES[@]}"; do
        echo -e "${YELLOW}   - $blocked_file${NC}"
    done
    echo ""
    echo -e "${YELLOW}To fix:${NC}"
    echo -e "${YELLOW}1. Remove or replace the detected secrets${NC}"
    echo -e "${YELLOW}2. Use environment variables instead: \${API_KEY}${NC}"
    echo -e "${YELLOW}3. Add secrets to .env files (and .gitignore them)${NC}"
    echo -e "${YELLOW}4. Use a secret management service${NC}"
    echo ""
    echo -e "${YELLOW}If this is a false positive, you can bypass with:${NC}"
    echo -e "${YELLOW}   git commit --no-verify${NC}"
    echo ""
    
    # Log the blocked attempt
    TIMESTAMP=$(date +%s)
    mkdir -p .claude/events
    echo "{\"event_id\":\"evt_${TIMESTAMP}_secret_blocked\",\"type\":\"SECRET_DETECTION_BLOCKED\",\"timestamp\":$TIMESTAMP,\"payload\":{\"files\":[\"$(IFS=','; echo "${BLOCKED_FILES[*]}")\"],\"commit_hash\":\"$(git rev-parse HEAD)\"}}" >> .claude/events/log.ndjson
    
    exit 1
else
    echo -e "${GREEN}âœ… No secrets detected - commit allowed${NC}"
    
    # Log successful scan
    TIMESTAMP=$(date +%s)
    mkdir -p .claude/events
    echo "{\"event_id\":\"evt_${TIMESTAMP}_secret_scan\",\"type\":\"SECRET_SCAN_PASSED\",\"timestamp\":$TIMESTAMP,\"payload\":{\"files_scanned\":$(echo "$FILES" | wc -l),\"commit_hash\":\"$(git rev-parse HEAD)\"}}" >> .claude/events/log.ndjson
    
    exit 0
fi